atlas-version
============

[![Gradle Plugin ID](https://img.shields.io/badge/gradle-net.wooga.github-brightgreen.svg?style=flat-square)](https://plugins.gradle.org/plugin/net.wooga.version)
[![Build Status](https://img.shields.io/travis/wooga/atlas-version/master.svg?style=flat-square)](https://travis-ci.org/wooga/atlas-version)
[![Coveralls Status](https://img.shields.io/coveralls/wooga/atlas-version/master.svg?style=flat-square)](https://coveralls.io/github/wooga/atlas-version?branch=master)
[![Apache 2.0](https://img.shields.io/badge/license-Apache%202-blue.svg?style=flat-square)](https://raw.githubusercontent.com/wooga/atlas-version/master/LICENSE)
[![GitHub tag](https://img.shields.io/github/tag/wooga/atlas-version.svg?style=flat-square)]()
[![GitHub release](https://img.shields.io/github/release/wooga/atlas-version.svg?style=flat-square)]()

A [gradle] plugin to generate semver version from the current git repository.

# Applying the plugin

**build.gradle**
```groovy
plugins {
    id 'net.wooga.version' version '0.1.0'
}
```

Documentation
=============

- [API docs](https://wooga.github.io/atlas-version/docs/api/)

Gradle and Java Compatibility
=============================

Built with OpenJDK8

| Gradle Version  | Works  |
| :-------------: | :----: |
| < 5.0           | ![no]  |
| 5.0             | ![no]  |
| 5.1             | ![yes] |
| 5.2             | ![yes] |
| 5.3             | ![yes] |
| 5.4             | ![yes] |
| 5.5             | ![yes] |
| 5.6             | ![yes] |
| 5.6             | ![yes] |
| 6.0             | ![yes] |
| 6.1             | ![yes] |
| 6.2             | ![yes] |
| 6.3             | ![yes] |
| 6.4             | ![yes] |
| 6.5             | ![yes] |
| 6.6             | ![yes] |
| 6.6             | ![yes] |
| 6.7             | ![yes] |
| 6.8             | ![yes] |
| 7.0             | ![yes] |

Development
===========

[Code of Conduct](docs/Code-of-conduct.md)

## How are versions generated?

### Version Anatomy
Versions are composed of normal, pre-release and metadata components.
Normal is the basic version (x.y.z), 
Pre-Release is the pre-release string that comes after the normal, separated by a minus(-) 
and Metadata is any metadata eventually attached into it, separated from its predecessors by a plus(+).
Versions must have a Normal component, but Pre-Release and Metadata components are optional. 

Those components are organized like this: normal-pre_release+metadata

Some examples:
```
normal = "1.0.0"
pre-release = "rc0001"
metadata = "commithash"

version = "1.0.0-rc0001+commithash"
```

```
normal = "1.0.0"
pre-release = "rc0001"
metadata = empty

version = "1.0.0-rc0001"
```

```
normal = "1.0.0"
pre-release = empty
metadata = "hash"

version = "1.0.0+hash"
```

### Strategies and Partial Strategies

Versions are generated by strategy objects (`VersionStrategy`). 
Strategies are associated to a release stage, and one or more stage names.
Strategies can be configured with partial strategies (`PartialSemverStrategy`) that transform certain components of a version.
Those partials are configured for each component of a version, describing how they are generated. 

Partial strategies are nothing more than a function that returns a transformed copy of a state (`SemverStrategyState`), 
that contains all the information necessary for generating a version. 
For instance, the Partial bellow appends the `"uncommited"` string to the pre-release component of a version being 
generated on a dirty git repository. 

```groovy
PartialSemVerStrategy SHOW_UNCOMMITTED = closure { state ->
    if (state.repoDirty) {
        def inferred = state.inferredPreRelease ? "${state.inferredPreRelease}.uncommitted" : 'uncommitted'
        state.copyWith(inferredPreRelease: inferred)
    } else {
        state
    }
}
```

Most of the partials used in this project are listed in the `Strategies` class, 
organized under the `Normal`, `PreRelease` or `BuildMetadata` subclasses accordingly with which component they change.

Bellow there is the full configuration of an example strategy

```groovy
[
    name: 'snapshot',
    releaseStage: ReleaseStage.Preflight,
    stages: ['pre', 'preflight', 'adhoc'] as SortedSet,    
    normalStrategy: Strategies.Normal.USE_MARKER_TAG,
    preReleaseStrategy: all(
            Strategies.PreRelease.STAGE_FIXED,
            Strategies.PreRelease.WITH_BRANCH_NAME
    ),
    buildMetadataStrategy: Strategies.BuildMetadata.COMMIT_ABBREVIATED_ID,
    enforcePrecedence: false,
    createTag: false,
]
```

The strategy above generates a semver-compliant version with the `Preflight` stage,
it accepts `pre`, `preflight` and `adhoc` as valid stage names.

It applies the `USE_MARKER_TAG` partial strategy to its normal component,
meaning its generated based on an existing marker tag.

It also applies the
`STAGE_FIXED`, `WITH_BRANCH_NAME` and `COUNT_COMMITS_SINCE_MARKER` partial strategies to its preRelease component,
meaning its pre-release components contains the current stage name and the current branch name.

Finally, it applies `COMMIT_ABREVIATED_ID` to the version metadata component, 
ensuring that the small version of a commit hash will be appended to its metadata component. 

`enforcePrecedence: false` and `createTag: false` means that this version won't fail if 
a previous version is higher than it, and it won't create a git tag on its generation. 


You will see that most often strategies are based from other already established strategies, like the example bellow.
```groovy
SemVerStrategy SNAPSHOT = SemverV2Strategies.SNAPSHOT.copyWith(
        normalStrategy: one(SemverV2Strategies.SNAPSHOT.normalStrategy, 
                            Strategies.Normal.useScope(ChangeScope.PATCH)),
)

```
The created strategy will be the same as the `SemverV2Strategies.SNAPSHOT` strategy, but it will use the `PATCH` scope to 
generate a new version if the semver v2 implementation can't solve it by itself. 


### Generating a version

Strategies are organized into schemes(`IVersionScheme`), which are bundles of strategies for different stages. 
The `development`, `snapshot`, `preRelease` and `final` stages are mandatory for all schemes, 
but you can add more stages as you please. Several schemes are described in the `VersionScheme` enum.

The user can pick a scheme, together with a stage and scope, that are used to determine which strategy 
will be used to generate a version.

Then, `VersionStrategy.infer()` will infer a version for the strategy. 
The execution will fail if a wrong scheme is provided, however, the Strategy itself can inform if a scheme is adequate or not for it,
through the `VersionStrategy.selector()` function. 


LICENSE
=======

Copyright 2020 Wooga GmbH

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

<http://www.apache.org/licenses/LICENSE-2.0>

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

<!-- Links -->
[gradle]:               https://gradle.org/ "Gradle"

[yes]:                  https://resources.atlas.wooga.com/icons/icon_check.svg "yes"
[no]:                   https://resources.atlas.wooga.com/icons/icon_uncheck.svg "no"
