# How are versions generated?

## Version Anatomy
Versions are composed of _normal_, _pre-release_ and _metadata_ components.
_Normal_ is the basic version (x.y.z),
_Pre-Release_ is the pre-release string that comes after the normal, separated by a minus (-)
and _Metadata_ is any metadata eventually attached into it, separated from its predecessors by a plus (+).
Versions must have a _Normal_ component, but _Pre-Release_ and _Metadata_ components are optional.

Those components are organized like this: normal-pre_release+metadata

Some examples:
```
normal = "1.0.0"
pre-release = "rc0001"
metadata = "commithash"

version = "1.0.0-rc0001+commithash"
```

```
normal = "1.0.0"
pre-release = "rc0001"
metadata = empty

version = "1.0.0-rc0001"
```

```
normal = "1.0.0"
pre-release = empty
metadata = "hash"

version = "1.0.0+hash"
```

## Strategies and Partial Strategies

Versions are generated by strategy objects (`VersionStrategy`).
_Strategies_ are associated to a release stage, and one or more stage names.
_Strategies_ can be configured with _partial_ strategies (`PartialSemverStrategy`) that transform certain components of a version.
Those _partials_ are configured for each component of a version, describing how they are generated.

_Partial_ strategies are nothing more than a function that returns a transformed copy of a state (`SemverStrategyState`),
that contains all the information necessary for generating a version.
For instance, the Partial below appends the `"uncommited"` string to the pre-release component of a version being
generated on a dirty git repository.

```groovy
PartialSemVerStrategy SHOW_UNCOMMITTED = closure { state ->
    if (state.repoDirty) {
        def inferred = state.inferredPreRelease ? "${state.inferredPreRelease}.uncommitted" : 'uncommitted'
        state.copyWith(inferredPreRelease: inferred)
    } else {
        state
    }
}
```

Most of the partials used in this project are listed in the `Strategies` class,
organized under the `Normal`, `PreRelease` or `BuildMetadata` subclasses accordingly with which component they change.

Below there is the full configuration of a new semver-compliant strategy as an example:

```groovy
new SemVerStrategy(
    name: 'snapshot',
    releaseStage: ReleaseStage.Preflight,
    stages: ['pre', 'preflight', 'adhoc'] as SortedSet,    
    normalStrategy: Strategies.Normal.USE_MARKER_TAG,
    preReleaseStrategy: all(
            Strategies.PreRelease.STAGE_FIXED,
            Strategies.PreRelease.WITH_BRANCH_NAME
    ),
    buildMetadataStrategy: Strategies.BuildMetadata.COMMIT_ABBREVIATED_ID,
    enforcePrecedence: false,
    createTag: false,
)
```

The strategy above generates a semver-compliant version with the `Preflight` stage,
it accepts `pre`, `preflight` and `adhoc` as valid stage names.

It applies the `USE_MARKER_TAG` partial strategy to its normal component,
meaning its generated based on an existing marker tag.

It also applies the
`STAGE_FIXED`, `WITH_BRANCH_NAME` and `COUNT_COMMITS_SINCE_MARKER` partial strategies to its preRelease component,
meaning its pre-release components contains the current stage name and the current branch name.

Finally, it applies `COMMIT_ABREVIATED_ID` to the version metadata component,
ensuring that the small version of a commit hash will be appended to its metadata component.

`enforcePrecedence: false` and `createTag: false` means that this version won't fail if
a previous version is higher than it, and it won't create a git tag on its generation.


You will see that most often strategies are based from other already established strategies, like the example below.
```groovy
SemVerStrategy SNAPSHOT = SemverV2Strategies.SNAPSHOT.copyWith(
        normalStrategy: one(SemverV2Strategies.SNAPSHOT.normalStrategy, 
                            Strategies.Normal.useScope(ChangeScope.PATCH)),
)

```
The created strategy will be the same as the `SemverV2Strategies.SNAPSHOT` strategy, but it will use the `PATCH` scope to
generate a new version if the semver v2 implementation can't solve it by itself.


## Generating a version

Strategies are organized into schemes(`IVersionScheme`), which are bundles of strategies for different stages.
The `development`, `snapshot`, `preRelease` and `final` stages are mandatory for all schemes,
but you can add more stages as you please. Several schemes are described in the `VersionScheme` enum.

The user can pick a scheme, together with a stage and scope, that are used to determine which strategy
will be used to generate a version.

Then, `VersionStrategy.infer()` will infer a version for the strategy.
The execution will fail if a wrong scheme is provided, however, the Strategy itself can inform if a scheme is adequate or not for it,
through the `VersionStrategy.selector()` function. 